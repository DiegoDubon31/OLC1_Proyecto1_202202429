package Analyzer;
import  java_cup.runtime.Symbol;

parser code {:
    
    
:}

action code
{:  :}


terminal STRAT, MATCH, MAIN, INITIAL, RULES, IF, THEN, ELSE, SCORING, RUN, WITH, SEED, PLAYERS, STRATS, ROUNDS, MUTUAL;
terminal COOPERATION, DEFECTION, BETRAYAL, REWARD, PUNISHMENT, TRUE, FALSE, AND, OR, NOT, EQUAL, INEQUAL, GREATER_THAN, LOWER_THAN;
terminal ROUNDOPEN, ROUNDCLOSE, GET_MOVE, LAST_MOVE, GET_MOVES_COUNT, GET_LAST_N_MOVES, ROUND_NUMBER, OPPONENT_HISTORY, SELF_HISTORY, TOTAL_ROUNDS, RANDOM;     
terminal GREATER_OR_EQUAL, LOWER_OR_EQUAL, CURLYOPEN, CURLYCLOSE, SQUAREOPEN, SQUARECLOSE, COLON, COMMA, COOPERATE, DEFECT, INTEGER, FLOAT, ID;        

non terminal AST S;
non terminal AST strategy, matches, begining, matchArg, scoreArg, beginingArg; 
non terminal AST strategyArg, decision, condition, conditions, booleanCondition, booleanExpression, matchesIds, logical, state;
non terminal AST funcs, func, comparison, history, decisionList, side, actions, arg1, arg2; 

precedence right NOT;  
precedence nonassoc EQUAL, INEQUAL, LOWER_THAN, GREATER_THAN, LOWER_OR_EQUAL, GREATER_OR_EQUAL; 
precedence left AND; 
precedence left OR;   

start with S;


S ::= strategy:str matches:m begining:b {: AST s = new AST("S");
                                            s.addChild(str);
                                            s.addChild(m);
                                            s.addChild(b);
                                            RESULT = s; :};
 
                          
matches ::= matches:m MATCH ID:i CURLYOPEN matchArg:arg CURLYCLOSE {:AST match = new AST("MATCH");
                                                            match.addChild(m);
                                                            match.addChild(new AST(i.toString()));
                                                            match.addChild(arg);
                                                            RESULT = match; :}
        | MATCH ID:i CURLYOPEN matchArg:arg CURLYCLOSE{:AST match = new AST("MATCH");
                                                            match.addChild(new AST(i.toString()));
                                                            match.addChild(arg);
                                                            RESULT = match; :};


matchArg ::= PLAYERS:p STRATS:s COLON SQUAREOPEN ID:i1 COMMA ID:i2 SQUARECLOSE
             ROUNDS:r COLON:c INTEGER:i
             SCORING:sc COLON CURLYOPEN scoreArg:sArg CURLYCLOSE
                                {:AST mArg = new AST("MATCH ARG");
                                mArg.addChild(new AST(p.toString()));
                                mArg.addChild(new AST(s.toString()));
                                mArg.addChild(new AST(i1.toString()));
                                mArg.addChild(new AST(i2.toString()));
                                mArg.addChild(new AST(r.toString()));
                                mArg.addChild(new AST(c.toString()));
                                mArg.addChild(new AST(i.toString()));
                                mArg.addChild(new AST(sc.toString()));
                                mArg.addChild(sArg); 
                                RESULT = mArg; :} ;
            

scoreArg ::= MUTUAL:m COOPERATION:c COLON INTEGER:i COMMA 
             MUTUAL:m1 DEFECTION:d COLON INTEGER:i1 COMMA
             BETRAYAL:b REWARD:r COLON INTEGER:i2 COMMA
             BETRAYAL:b1 PUNISHMENT:p COLON INTEGER:i3
                                                {: AST score = new AST("SCORE");
                                                score.addChild(new AST(m.toString()));
                                                score.addChild(new AST(c.toString()));
                                                score.addChild(new AST(i.toString()));
                                                score.addChild(new AST(m1.toString()));
                                                score.addChild(new AST(d.toString()));
                                                score.addChild(new AST(i1.toString()));
                                                score.addChild(new AST(b.toString()));
                                                score.addChild(new AST(r.toString()));
                                                score.addChild(new AST(i2.toString()));
                                                score.addChild(new AST(b1.toString()));
                                                score.addChild(new AST(p.toString()));
                                                score.addChild(new AST(i3.toString()));
                                                RESULT = score; :} ;

begining ::= MAIN CURLYOPEN beginingArg:beginArg CURLYCLOSE {:AST begin = new AST("MAIN");
                                                                begin.addChild(beginArg);
                                                                RESULT = begin; :} ;


beginingArg ::= beginingArg:bArg RUN:r SQUAREOPEN matchesIds:Ids SQUARECLOSE WITH CURLYOPEN SEED:d COLON INTEGER:s CURLYCLOSE {:AST run = new AST("RUN");
                                                                                                            run.addChild(bArg);
                                                                                                            run.addChild(new AST(r.toString()));
                                                                                                            run.addChild(Ids);
                                                                                                            run.addChild(new AST(d.toString()));
                                                                                                            run.addChild(new AST(s.toString()));
                                                                                                            RESULT = run; :} 
                | RUN:r SQUAREOPEN matchesIds:Ids SQUARECLOSE WITH CURLYOPEN SEED:d COLON INTEGER:s CURLYCLOSE{:AST run = new AST("RUN");
                                                                                                            run.addChild(new AST(r.toString()));
                                                                                                            run.addChild(Ids);
                                                                                                            run.addChild(new AST(d.toString()));
                                                                                                            run.addChild(new AST(s.toString()));
                                                                                                            RESULT = run; :} ; 

matchesIds ::= matchesIds:i COMMA ID:i1 {: AST idList = new AST("MATCH_ID");
                                            idList.addChild(i);
                                            idList.addChild(new AST(i1.toString()));
                                            RESULT = idList; :}  
                | ID:i {: AST idList = new AST("MATCH_ID");
                        idList.addChild(new AST(i.toString()));
                        RESULT = idList; :};         

strategy ::= strategy:str STRAT ID:id CURLYOPEN strategyArg:arg CURLYCLOSE{:AST strat = new AST("STRATEGY");
                                                                strat.addChild(str);
                                                                strat.addChild(new AST(id.toString()));
                                                                strat.addChild(arg);
                                                                RESULT = strat; :} 
            | STRAT ID:id CURLYOPEN strategyArg:arg CURLYCLOSE{:AST strat = new AST("STRATEGY");
                                                                strat.addChild(new AST(id.toString()));
                                                                strat.addChild(arg);
                                                                RESULT = strat; :};

 
strategyArg ::= INITIAL:i COLON decision:d 
                RULES:r COLON SQUAREOPEN conditions:c SQUARECLOSE
                                            {:AST dec = new AST("STRATEGY ARGUMENT");
                                            dec.addChild(new AST(i.toString()));
                                            dec.addChild(d);
                                            dec.addChild(new AST(r.toString()));
                                            dec.addChild(c);
                                            RESULT = dec; :} ;

conditions ::= conditions:cs condition:c {:AST cond = new AST("CONDITIONS");
                                            cond.addChild(cs);
                                            cond.addChild(c);
                                            RESULT = cond; :} 
                | condition:c {:AST cond = new AST("CONDITIONS");
                                            cond.addChild(c);
                                            RESULT = cond; :} ;


condition ::= IF:i booleanExpression:bc THEN:t actions:d COMMA{:AST con = new AST("CONDITION");
                                                        con.addChild(new AST(i.toString()));
                                                        con.addChild(bc);
                                                        con.addChild(new AST(t.toString()));
                                                        con.addChild(d);
                                                        RESULT = con; :}
                | ELSE:e actions:d {:AST con = new AST("CONDITION");
                                    con.addChild(new AST(e.toString()));
                                    con.addChild(d);
                                    RESULT = con; :};


            
booleanExpression ::= booleanExpression:bs logical:l booleanExpression:b {:AST Bcond = new AST("BOOLEAN EXPRESSION");
                                                                            Bcond.addChild(bs);
                                                                            Bcond.addChild(l);
                                                                            Bcond.addChild(b);
                                                                            RESULT = Bcond; :}
                    | booleanCondition:b {:AST Bcond = new AST("BOOLEAN EXPRESSION");
                                            Bcond.addChild(b);
                                            RESULT = Bcond; :} ; 

booleanCondition ::= side:s1 comparison:s2 side:s3 {: AST bool = new AST("BOOLEAN CONDITION");
                                                bool.addChild(s1);
                                                bool.addChild(s2);
                                                bool.addChild(s3);
                                                RESULT = bool; :} ;

side ::= funcs:f {: AST s = new AST("SIDE OPERATOR");
                    s.addChild(f);
                    RESULT = s; :} 
        | state:f {: AST s = new AST("SIDE OPERATOR");
                    s.addChild(f);
                    RESULT = s; :} 
        | decision:f {: AST s = new AST("SIDE OPERATOR");
                            s.addChild(f);
                            RESULT = s; :}
        | SQUAREOPEN decisionList:f SQUARECLOSE {: AST s = new AST("SIDE OPERATOR");
                            s.addChild(f);
                            RESULT = s; :}
        | INTEGER:f {: AST s = new AST("SIDE OPERATOR");
                            s.addChild(new AST(f.toString()));
                            RESULT = s; :}
        | FLOAT:f {: AST s = new AST("SIDE OPERATOR");
                            s.addChild(new AST(f.toString()));
                            RESULT = s; :};


actions ::= decision:c {:AST acts = new AST("ACTION");
                            acts.addChild(c);
                            RESULT = acts; :}
            | funcs:c {:AST acts = new AST("ACTION");
                            acts.addChild(c);
                            RESULT = acts; :}; 

decision ::= COOPERATE:c {:AST act = new AST("DECISION");
                            act.addChild(new AST(c.toString()));
                            RESULT = act; :} 
            | DEFECT:d {:AST act = new AST("DECISION");
                            act.addChild(new AST(d.toString()));
                            RESULT = act; :} ;

logical ::= AND:a {: AST log = new AST("LOGICAL");
                    log.addChild(new AST(a.toString()));
                    RESULT = log; :} 
            | OR:o {: AST log = new AST("LOGICAL");
                    log.addChild(new AST(o.toString()));
                    RESULT = log; :};


state ::= ROUND_NUMBER:r {: AST stArg = new AST("STATE");
                                stArg.addChild(new AST(r.toString()));
                                RESULT = stArg; :} 
            | TOTAL_ROUNDS:r {: AST stArg = new AST("STATE");
                                stArg.addChild(new AST(r.toString()));
                                RESULT = stArg; :}
            | RANDOM:r {: AST stArg = new AST("STATE");
                                stArg.addChild(new AST(r.toString()));
                                RESULT = stArg; :} ;

funcs ::= funcs:fs func:f {: AST funs = new AST("FUNCTIONS");
                                funs.addChild(fs);
                                funs.addChild(f);
                                RESULT = funs; :}
            | func:f {: AST funs = new AST("FUNCTIONS");
                        funs.addChild(f);
                        RESULT = funs; :} ; 

func ::= GET_MOVE:n ROUNDOPEN arg1:a1 COMMA arg2:a2 ROUNDCLOSE {: AST fun = new AST("FUNCTION");
                                                                fun.addChild(new AST(n.toString()));
                                                                fun.addChild(a1);
                                                                fun.addChild(a2);
                                                                RESULT = fun; :}
        | LAST_MOVE:n ROUNDOPEN arg1:a1 ROUNDCLOSE {: AST fun = new AST("FUNCTION");
                                                    fun.addChild(new AST(n.toString()));
                                                    fun.addChild(a1);
                                                    RESULT = fun; :} 
        | GET_MOVES_COUNT:n ROUNDOPEN arg1:a1 COMMA arg2:a2 ROUNDCLOSE {: AST fun = new AST("FUNCTION");
                                                                        fun.addChild(new AST(n.toString()));
                                                                        fun.addChild(a1);
                                                                        fun.addChild(a2);
                                                                        RESULT = fun; :}
        | GET_LAST_N_MOVES:n ROUNDOPEN arg1:a1 COMMA arg2:a2 ROUNDCLOSE  {: AST fun = new AST("FUNCTION");
                                                                                fun.addChild(new AST(n.toString()));
                                                                                fun.addChild(a1);
                                                                                fun.addChild(a2);                                                                                
                                                                                RESULT = fun; :}; 

arg1 ::= history:h {: AST arg1 = new AST("FUNCTION ARG1");
                        arg1.addChild(h);
                        RESULT = arg1; :} 
        | func:h {: AST arg1 = new AST("FUNCTION ARG1");
                arg1.addChild(h);
                RESULT = arg1; :}
        | state:h {: AST arg1 = new AST("FUNCTION ARG1");
                arg1.addChild(h);
                RESULT = arg1; :} ;

arg2 ::= INTEGER:h {: AST arg2 = new AST("FUNCTION ARG2");
                        arg2.addChild(new AST(h.toString()));
                        RESULT = arg2; :}  
        | decision:h {: AST arg2 = new AST("FUNCTION ARG2");
                        arg2.addChild(h);
                        RESULT = arg2; :}  
        | func:h {: AST arg2 = new AST("FUNCTION ARG2");
                        arg2.addChild(h);
                        RESULT = arg2; :} 
        | state:h {: AST arg2 = new AST("FUNCTION ARG2");
                arg2.addChild(h);
                RESULT = arg2; :};

comparison ::= EQUAL:c {: AST comp = new AST("COMPARISON");
                            comp.addChild(new AST(c.toString()));
                            RESULT = comp; :} 
               | INEQUAL:c {: AST comp = new AST("COMPARISON");
                            comp.addChild(new AST(c.toString()));
                            RESULT = comp; :} 
               | LOWER_THAN:c {: AST comp = new AST("COMPARISON");
                            comp.addChild(new AST(c.toString()));
                            RESULT = comp; :} 
               | GREATER_THAN:c {: AST comp = new AST("COMPARISON");
                            comp.addChild(new AST(c.toString()));
                            RESULT = comp; :} 
               | LOWER_OR_EQUAL:c {: AST comp = new AST("COMPARISON");
                            comp.addChild(new AST(c.toString()));
                            RESULT = comp; :} 
               | GREATER_OR_EQUAL:c {: AST comp = new AST("COMPARISON");
                            comp.addChild(new AST(c.toString()));
                            RESULT = comp; :} ;


history ::= OPPONENT_HISTORY:h {: AST hist = new AST("HISTORY");
                                    hist.addChild(new AST(h.toString()));
                                    RESULT = hist; :} 
            | SELF_HISTORY:h {: AST hist = new AST("HISTORY");
                                    hist.addChild(new AST(h.toString()));
                                    RESULT = hist; :};

decisionList ::=  decisionList:d1 COMMA decision:d2 {: AST dList = new AST("DECISION LIST");
                                    dList.addChild(d1);
                                    dList.addChild(d2);
                                    RESULT = dList; :} 
                | decision:d1 {: AST dList = new AST("DECISION LIST");
                                    dList.addChild(d1);
                                    RESULT = dList; :} ;  